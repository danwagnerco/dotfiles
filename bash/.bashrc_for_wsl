# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# save multi-line commands as one command in the history
shopt -s cmdhist

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        # We have color support; assume it's compliant with Ecma-48
        # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
        # a case would tend to support setf rather than setaf.)
        color_prompt=yes
    else
        color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# Dan's aliases
alias eee="eza -l -a -h --group-directories-first"
alias gll="git log --oneline -10"
alias gss="git status"

# kimi
# function wrapper that uses Moonshot AI's Kimi model with Claude Code CLI
function kimi() {
    (
        export ANTHROPIC_BASE_URL=https://api.moonshot.ai/anthropic
        export ANTHROPIC_AUTH_TOKEN=<secret>
        export ANTHROPIC_MODEL=kimi-k2-thinking
        export ANTHROPIC_SMALL_FAST_MODEL=kimi-k2-thinking
        /home/danwagnerco/.claude/local/claude "$@"
    )
}

# ============================================================================
# BASH PROMPT CONFIGURATION
# Multi-line prompt with git status, venv, and path truncation
# ============================================================================

# Colors for prompt
COLOR_RESET='\[\033[0m\]'
COLOR_CYAN='\[\033[36m\]'
COLOR_GREEN='\[\033[32m\]'
COLOR_YELLOW='\[\033[33m\]'
COLOR_BLUE='\[\033[34m\]'
COLOR_MAGENTA='\[\033[35m\]'
COLOR_RED='\[\033[31m\]'

# Git prompt configuration (uses built-in git-prompt if available)
if [ -f /usr/lib/git-core/git-sh-prompt ]; then
    source /usr/lib/git-core/git-sh-prompt
elif [ -f /usr/share/git-core/contrib/completion/git-prompt.sh ]; then
    source /usr/share/git-core/contrib/completion/git-prompt.sh
fi

# Configure git prompt settings (similar to posh-git)
export GIT_PS1_SHOWDIRTYSTATE=1        # '*' for unstaged, '+' for staged
export GIT_PS1_SHOWSTASHSTATE=1        # '$' if stash exists
export GIT_PS1_SHOWUNTRACKEDFILES=1    # '%' if untracked files exist
export GIT_PS1_SHOWUPSTREAM="auto"     # '<' behind, '>' ahead, '<>' diverged, '=' equal

# Prevent Python venv from modifying prompt (we handle it ourselves)
export VIRTUAL_ENV_DISABLE_PROMPT=1

# Function to get last 3 path segments
get_truncated_path() {
    local path="$PWD"
    local home="$HOME"

    # Replace home with ~
    path="${path/#$home/\~}"

    # Split path and get last 3 segments
    IFS='/' read -ra PARTS <<< "$path"
    local count=${#PARTS[@]}

    if [ $count -gt 3 ]; then
        echo ".../${PARTS[-3]}/${PARTS[-2]}/${PARTS[-1]}"
    else
        echo "$path"
    fi
}

# Function to create custom multi-line prompt
set_bash_prompt() {
    local exit_code=$?

    # Line 1: Blank line for visual separation
    PS1="\n"

    # Line 2A: Username@hostname
    PS1+="${COLOR_GREEN}\u@\h${COLOR_RESET} "

    # Line 2B: Current directory (truncated to last 3 segments)
    PS1+="${COLOR_CYAN}\$(get_truncated_path)${COLOR_RESET}"

    # Line 2C: Virtual environment (if active)
    if [ -n "$VIRTUAL_ENV" ]; then
        local venv_leaf=$(basename "$VIRTUAL_ENV")
        if [ "$venv_leaf" = ".venv" ]; then
            # uv-style: .venv inside project folder, show project name
            local venv_name=$(basename "$(dirname "$VIRTUAL_ENV")")
        else
            # poetry-style: descriptive venv name, use as-is
            local venv_name="$venv_leaf"
        fi
        PS1+=" ${COLOR_GREEN}(${venv_name})${COLOR_RESET}"
    fi

    # Line 2D: Git status (if in a git repo)
    if type -t __git_ps1 > /dev/null; then
        PS1+="${COLOR_MAGENTA}\$(__git_ps1 ' [%s]')${COLOR_RESET}"
    fi

    # Line 3: Prompt character
    PS1+="\n${COLOR_YELLOW}\$${COLOR_RESET} "
}

# Set prompt command to run before each prompt
PROMPT_COMMAND=set_bash_prompt

# Function to activate Poetry virtual environment
# "Poetry Environment Activate (pea)"
pea() {
    if [ ! -f "pyproject.toml" ]; then
        echo -e "\033[31mNo Poetry project found in current directory\033[0m"
        return 1
    fi

    # Get the activation command from poetry
    local activate_script=$(poetry env info -p 2>/dev/null)

    if [ -z "$activate_script" ]; then
        echo -e "\033[31mNo Poetry virtual environment found in this project\033[0m"
        return 1
    fi

    source "${activate_script}/bin/activate"
}

# Function to deactivate Poetry virtual environment
# "Poetry Environment Deactivate (ped)"
ped() {
    if [ -n "$VIRTUAL_ENV" ]; then
        deactivate
    else
        echo -e "\033[33mNo active virtual environment to deactivate\033[0m"
    fi
}

# Function to print tree views via eza
etree() {
    local depth=$1
    local base_args=(-l -a -h --no-permissions --no-filesize --no-user --no-time --no-git --tree --git-ignore --ignore-glob='.git' --ignore-glob='.venv')
    
    if [[ -n "$depth" ]] && [[ "$depth" =~ ^[0-9]+$ ]]; then
        eza "${base_args[@]}" --level="$depth"
    else
        eza "${base_args[@]}"
    fi
}

# Environment variables
export UW_TOKEN=<secret>
export UW_API_TOKEN=<secret>
export UW_EMPLOYEE_KEY=<secret>
export TIINGO_API_TOKEN=<secret>
export UW_DEMO_TOKEN=<secret>
export UW_ASKSHERLOCK_TOKEN=<secret>
export UW_ABYAN_TOKEN=<secret>
export DUCKDB_KEY_ID=<secret>
export DUCKDB_SECRET=<secret>
export OPEN_FIGI_TOKEN=<secret>
export GH_TOKEN=<secret>

# Path management
export PATH="/home/danwagnerco/.local/bin:$PATH"
export PATH="/opt/SQLiteStudio:$PATH"

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

alias claude="/home/danwagnerco/.claude/local/claude"
. "$HOME/.cargo/env"
